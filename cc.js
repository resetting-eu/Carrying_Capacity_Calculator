function walkableArea(features,bounds,options={},workerId,progressCallback,progress={processedPolygons:0,totalPolygons:0}){let LANE_WIDTH=3;let RAIL_WIDTH=3;let PARALLEL_PARKING_WIDTH=2;let DIAGONAL_PARKING_WIDTH=5;let REMOVE_BUILDING_INNER_RINGS=true;let WALKABLE_ROADS=false;let UNWALKABLE_GRASS=false;if(options.laneWidth)LANE_WIDTH=options.laneWidth;if(options.railWidth)RAIL_WIDTH=options.railWidth;if(options.parallelWidth)PARALLEL_PARKING_WIDTH=options.parallelWidth;if(options.diagonalWidth)DIAGONAL_PARKING_WIDTH=options.diagonalWidth;if(options.flattenBuildings)REMOVE_BUILDING_INNER_RINGS=options.flattenBuildings;if(options.walkableRoads)WALKABLE_ROADS=options.walkableRoads;if(options.unwalkableGrass)UNWALKABLE_GRASS=options.unwalkableGrass;let filteredFeatures=filterFeatures(features,bounds);let roads=filteredFeatures.roads;let railways=filteredFeatures.railways;let buildings=filteredFeatures.buildings;let waterBodies=filteredFeatures.waterBodies;let restrictedAreas=filteredFeatures.restrictedAreas;let grass=filteredFeatures.grass;let benches=filteredFeatures.benches;let trees=filteredFeatures.trees;let smallMonuments=filteredFeatures.smallMonuments;let barriers=filteredFeatures.barriers;let land=filteredFeatures.land;let bridges=filteredFeatures.bridges;let boundaries=filteredFeatures.boundaries;if(WALKABLE_ROADS){roads=[]}else{roads=processRoads(roads,LANE_WIDTH,DIAGONAL_PARKING_WIDTH,PARALLEL_PARKING_WIDTH)}buildings=processBuildings(buildings,REMOVE_BUILDING_INNER_RINGS);railways=addBufferMany(railways,RAIL_WIDTH/2);bridges=addBufferMany(bridges,.01);waterBodies=addBufferMany(waterBodies,.05);benches=processBenches(benches);trees=processTrees(trees);smallMonuments=processSmallMonuments(smallMonuments);barriers=processBarriers(barriers);let waterWithBridges=[];console.log("Boundaries:");console.log(boundaries);if(boundaries.length==0){if(land.length==0){return addBuffer(turf.centroid(bounds),.01)}}else{if(!turf.booleanWithin(bounds,boundaries[0])){let unmappedWater=turf.difference(bounds,boundaries[0]);waterWithBridges.push(unmappedWater)}}for(let water of waterBodies){waterWithBridges.push(differenceMany(water,bridges))}let unwalkablePolygons=buildings.concat(waterWithBridges,roads,railways,restrictedAreas,benches,trees,smallMonuments,barriers);if(UNWALKABLE_GRASS){unwalkablePolygons=unwalkablePolygons.concat(grass)}if(options.customFeatures){console.log("Custom geometries:");console.log(options.customFeatures.features);unwalkablePolygons=unwalkablePolygons.concat(options.customFeatures.features)}let walkableAreaPolygon=bounds;console.log("Unwalkable features: "+unwalkablePolygons.length);for(let f of unwalkablePolygons){try{let diff=turf.difference(walkableAreaPolygon,f);if(diff===null)diff=addBuffer(turf.centroid(bounds),.01);walkableAreaPolygon=diff}catch(error){console.log("Error with feature:");console.log(f);console.log(error)}progress.processedPolygons++;let processedPolygons=progress.processedPolygons;let totalPolygons=progress.totalPolygons}return walkableAreaPolygon}function walkableAreaWithSubAreas(features,bounds,options,workerId){bounds_area=turf.area(bounds);numDivisions=Math.ceil(bounds_area/1e5);numDivisions=numDivisions>=1?numDivisions:1;let subAreas=divideArea(bounds,numDivisions,horizontal=false);let subAreaFeatures=[];let totalPolygons=0;let unwalkablePolygons=[];for(let subArea of subAreas){let subFeatures=[];for(let feature of features){if(turf.booleanIntersects(feature,subArea)){subFeatures.push(feature)}}subAreaFeatures.push(subFeatures)}progress={totalPolygons:totalPolygons,processedPolygons:0};console.log(subAreaFeatures);for(let i=0;i<subAreas.length;i++){unwalkablePolygons.push(walkableArea(subAreaFeatures[i],subAreas[i],options,workerId,null,progress));if(workerId!==undefined&&workerId!==null){postMessage({progress:true,processedPolygons:i+1,totalPolygons:subAreas.length,workerId:workerId})}}results=[];try{results=unionArray(unwalkablePolygons)}catch(e){unwalkablePolygons=addBufferMany(unwalkablePolygons,.01);try{results=unionArray(unwalkablePolygons)}catch(e1){alert("There are geometry issues with the unions involved in this . Try another time");console.log(e)}}return results}function filterFeatures(features,bounds){let filteredFeatures={roads:[],railways:[],buildings:[],waterBodies:[],restrictedAreas:[],benches:[],trees:[],smallMonuments:[],grass:[],bridges:[],barriers:[],boundaries:[],land:[]};for(let feature of features){if(isBuilding(feature))filteredFeatures.buildings.push(feature);else if(isWater(feature))filteredFeatures.waterBodies.push(turf.intersect(feature,bounds));else if(isRoad(feature))filteredFeatures.roads.push(feature);else if(isRailway(feature))filteredFeatures.railways.push(feature);else if(isBridge(feature))filteredFeatures.bridges.push(feature);else if(isRestrictedArea(feature))filteredFeatures.restrictedAreas.push(feature);else if(isBench(feature))filteredFeatures.benches.push(feature);else if(isTree(feature))filteredFeatures.trees.push(feature);else if(isSmallMonument(feature))filteredFeatures.smallMonuments.push(feature);else if(isGrass(feature))filteredFeatures.grass.push(feature);else if(isBarrier(feature))filteredFeatures.barriers.push(feature);else if(isBoundary(feature))filteredFeatures.boundaries.push(feature);else if(isLand(feature))filteredFeatures.land.push(feature)}return filteredFeatures}function isRoad(feature){return feature.properties.highway&&feature.properties.highway!="pedestrian"&&feature.properties.foot!="designated"&&!feature.properties.footway&&feature.properties.highway!="footway"&&feature.properties.highway!="steps"&&feature.properties.highway!="cycleway"&&feature.properties.highway!="path"&&isAboveGround(feature)&&isLine(feature)}function isRailway(feature){return feature.properties.railway&&feature.properties.railway!="razed"&&feature.properties.railway!="abandoned"&&isAboveGround(feature)&&isLine(feature)}function isBuilding(feature){return feature.properties.building&&isAboveGround(feature)&&isPolygon(feature)}function isWater(feature){return(feature.properties.natural=="water"||feature.properties.place=="sea"||feature.properties.natural=="bay"||feature.properties.natural=="strait"||feature.properties.natural=="wetlands"||feature.properties.natural=="mud")&&isPolygon(feature)}function isBridge(feature){return feature.properties.man_made=="bridge"&&isPolygon(feature)}function isTree(feature){return(feature.properties.natural=="tree"||feature.properties.natural=="tree_row")&&isPoint(feature)}function isBench(feature){return feature.properties.amenity=="bench"&&isPoint(feature)}function isSmallMonument(feature){return(feature.properties.artwork_type||feature.properties.tourism=="artwork"||feature.properties.historic=="monument"||feature.properties.historic=="memorial")&&isPoint(feature)}function isGrass(feature){return feature.properties.landuse=="grass"&&isPolygon(feature)}function isRestrictedArea(feature){return(feature.properties.landuse=="military"||feature.properties.aeroway)&&isPolygon(feature)}function isBarrier(feature){return feature.properties.barrier&&feature.properties.barrier!="kerb"}function isBoundary(feature){return feature.properties.boundary=="administrative"}function isAboveGround(feature){if(feature.properties.layer)return parseInt(feature.properties.layer)>-1;return true}function isLand(feature){return feature.properties.place||feature.properties.landuse||feature.properties.natural&&!isWater(feature)}function isLine(feature){return feature.geometry.type=="LineString"}function isPolygon(feature){return feature.geometry.type.includes("Polygon")}function isPoint(feature){return feature.geometry.type=="Point"}function isPoint(feature){return feature.geometry.type=="Point"}function processSmallMonuments(features){let processed=[];for(f of features){processed.push(addBuffer(f,1))}return processed}function processBuildings(features,removeInnerRings=true){let processed=[];for(f of features){if(removeInnerRings&&f.geometry.type=="Polygon"){let outerRing=f.geometry.coordinates[0];f.geometry.coordinates=[outerRing]}processed.push(addBuffer(f,.01))}return processed}function processBenches(features){let processed=[];for(f of features){processed.push(turf.buffer(f,.5,{units:"meters",steps:4}))}return processed}function processTrees(features){let processed=[];for(f of features){processed.push(addBuffer(f,.5))}return processed}function processBarriers(features){let processed=[];for(f of features){processed.push(addBuffer(f,.4))}return processed}function processRoads(roads,laneWidth,diagonalWidth,parallelWidth){let processed=[];for(let road of roads){let numLanes=parseInt(road.properties["lanes"]?road.properties["lanes"]:1);let numBusLanes=parseInt(road.properties["lanes:bus"]?road.properties["lanes:bus"]:0);let estWidth=(numLanes+numBusLanes)*laneWidth;if(road.properties["parking:lane:left"])if(road.properties["parking:lane:left"]=="parallel")estWidth+=parallelWidth;else estWidth+=diagonalWidth;if(road.properties["parking:lane:right"])if(road.properties["parking:lane:right"]=="parallel")estWidth+=parallelWidth;else estWidth+=diagonalWidth;if(road.properties["parking:lane:both"])if(road.properties["parking:lane:both"]=="parallel")estWidth+=parallelWidth*2;else estWidth+=diagonalWidth*2;road.properties["estWidth"]=estWidth;processed.push(turf.buffer(road,estWidth/2,{units:"meters"}))}return processed}function addBuffer(feature,value){try{return turf.buffer(feature,value,{units:"meters"})}catch(error){console.log(feature);console.log(error)}}function addBufferMany(features,value){let buffered=[];for(let feature of features){buffered.push(addBuffer(feature,value))}return buffered}function differenceMany(feature,features){let diff=feature;for(let f of features){diff=turf.difference(diff,f)}return diff}function unionMany(feature,features){let union=feature;for(let f of features){union=turf.union(union,f)}return union}function unionArray(features){let union=features.shift();for(let f of features){union=turf.union(union,f)}return union}function divideArea(bounds,numAreas,horizontal=true){let bbox=turf.bbox(bounds);let minX=bbox[0];let minY=bbox[1];let maxX=bbox[2];let maxY=bbox[3];let deltaX=(maxX-minX)/numAreas;let deltaY=(maxY-minY)/numAreas;let subAreas=[];for(let i=0;i<numAreas;i++){let points;if(horizontal){points=[[[minX+i*deltaX,maxY],[minX+(i+1)*deltaX,maxY],[minX+(i+1)*deltaX,minY],[minX+i*deltaX,minY],[minX+i*deltaX,maxY]]]}else{points=[[[minX,maxY-i*deltaY],[maxX,maxY-i*deltaY],[maxX,maxY-(i+1)*deltaY],[minX,maxY-(i+1)*deltaY],[minX,maxY-i*deltaY]]]}let subArea=addBuffer(turf.polygon(points),.01);subAreas.push(turf.intersect(subArea,bounds))}return subAreas}