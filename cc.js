function filterFeatures(features,bounds){let filteredFeatures={roads:[],railways:[],buildings:[],waterBodies:[],restrictedAreas:[],benches:[],trees:[],smallMonuments:[],grass:[],bridges:[],barriers:[],boundaries:[],land:[],coastlines:[]};for(let feature of features){if(isBuilding(feature))filteredFeatures.buildings.push(feature);if(isWater(feature))filteredFeatures.waterBodies.push(turf.intersect(turf.featureCollection([feature,bounds])));if(isRoad(feature))filteredFeatures.roads.push(feature);if(isRailway(feature))filteredFeatures.railways.push(feature);if(isBridge(feature))filteredFeatures.bridges.push(feature);if(isRestrictedArea(feature))filteredFeatures.restrictedAreas.push(feature);if(isBench(feature))filteredFeatures.benches.push(feature);if(isTree(feature))filteredFeatures.trees.push(feature);if(isSmallMonument(feature))filteredFeatures.smallMonuments.push(feature);if(isGrass(feature))filteredFeatures.grass.push(feature);if(isBarrier(feature))filteredFeatures.barriers.push(feature);if(isBoundary(feature))filteredFeatures.boundaries.push(feature);if(isLand(feature))filteredFeatures.land.push(feature);if(isCoastline(feature))filteredFeatures.coastlines.push(feature)}return filteredFeatures}function isRoad(feature){return feature.properties.highway&&feature.properties.highway!="pedestrian"&&feature.properties.foot!="designated"&&!feature.properties.footway&&feature.properties.highway!="footway"&&feature.properties.highway!="steps"&&feature.properties.highway!="cycleway"&&feature.properties.highway!="path"&&isAboveGround(feature)&&isLine(feature)}function isRailway(feature){return feature.properties.railway&&feature.properties.railway!="razed"&&feature.properties.railway!="abandoned"&&isAboveGround(feature)&&isLine(feature)}function isBuilding(feature){return feature.properties.building&&isAboveGround(feature)&&isPolygon(feature)}function isWater(feature){return(feature.properties.natural=="water"||feature.properties.place=="sea"||feature.properties.natural=="bay"||feature.properties.natural=="strait"||feature.properties.natural=="wetlands"||feature.properties.natural=="mud"||feature.properties.natural=="shoal"||feature.properties.waterway)&&isPolygon(feature)}function isBridge(feature){return feature.properties.man_made=="bridge"&&isPolygon(feature)}function isTree(feature){return(feature.properties.natural=="tree"||feature.properties.natural=="tree_row")&&isPoint(feature)}function isBench(feature){return feature.properties.amenity=="bench"&&isPoint(feature)}function isSmallMonument(feature){return feature.properties.artwork_type||feature.properties.tourism=="artwork"||feature.properties.historic=="monument"||feature.properties.historic=="memorial"}function isGrass(feature){return feature.properties.landuse=="grass"&&isPolygon(feature)}function isRestrictedArea(feature){return(feature.properties.landuse=="military"||feature.properties.aeroway)&&isPolygon(feature)}function isBarrier(feature){return feature.properties.barrier&&feature.properties.barrier!="kerb"&&!isPolygon(feature)}function isBoundary(feature){return feature.properties.boundary&&feature.properties.boundary=="administrative"&&isPolygon(feature)}function isAboveGround(feature){if(feature.properties.layer)return parseInt(feature.properties.layer)>-1;return true}function isLand(feature){return feature.properties.place||feature.properties.landuse||feature.properties.natural&&!isWater(feature)}function isCoastline(feature){return feature.properties.natural&&feature.properties.natural==="coastline"}function isLine(feature){return feature.geometry.type=="LineString"}function isPolygon(feature){return feature.geometry.type.includes("Polygon")}function isPoint(feature){return feature.geometry.type=="Point"}function isPoint(feature){return feature.geometry.type=="Point"}function processSmallMonuments(features){let processed=[];for(f of features){if(isPolygon(f))processed.push(addBuffer(f,.01));else processed.push(addBuffer(f,1))}return processed}function processBuildings(features,removeInnerRings=true){let processed=[];for(f of features){if(removeInnerRings&&f.geometry.type=="Polygon"){let outerRing=f.geometry.coordinates[0];f.geometry.coordinates=[outerRing]}processed.push(addBuffer(f,.01))}return processed}function processBenches(features){let processed=[];for(f of features){processed.push(turf.buffer(f,.5,{units:"meters",steps:4}))}return processed}function processTrees(features){let processed=[];for(f of features){processed.push(addBuffer(f,.5))}return processed}function processBarriers(features){let processed=[];for(f of features){processed.push(addBuffer(f,.4))}return processed}function processWater(filteredFeatures,bounds){bridges=addBufferMany(filteredFeatures.bridges,.01);waterBodies=addBufferMany(filteredFeatures.waterBodies,.05);processed=[];for(let water of waterBodies){processed.push(differenceMany(water,bridges))}return processed}function processRoads(roads,laneWidth,diagonalWidth,parallelWidth){let processed=[];for(let road of roads){let numLanes=parseInt(road.properties["lanes"]?road.properties["lanes"]:1);let numBusLanes=parseInt(road.properties["lanes:bus"]?road.properties["lanes:bus"]:0);let estWidth=(numLanes+numBusLanes)*laneWidth;if(road.properties["parking:lane:left"])if(road.properties["parking:lane:left"]=="parallel")estWidth+=parallelWidth;else estWidth+=diagonalWidth;if(road.properties["parking:lane:right"])if(road.properties["parking:lane:right"]=="parallel")estWidth+=parallelWidth;else estWidth+=diagonalWidth;if(road.properties["parking:lane:both"])if(road.properties["parking:lane:both"]=="parallel")estWidth+=parallelWidth*2;else estWidth+=diagonalWidth*2;road.properties["estWidth"]=estWidth;processed.push(turf.buffer(road,estWidth/2,{units:"meters"}))}return processed}function addBuffer(feature,value){try{return turf.buffer(feature,value,{units:"meters"})}catch(error){console.log(feature);console.log(error)}}function addBufferMany(features,value){let buffered=[];for(let feature of features){buffered.push(addBuffer(feature,value))}return buffered}function difference(feature1,feature2){return turf.difference(turf.featureCollection([feature1,feature2]))}function differenceMany(feature,features){if(features.length==0)return feature;return turf.difference(turf.featureCollection([feature,...features]))}function unionMany(feature,features){let union=feature;for(let f of features){union=turf.union(union,f)}return union}function unionArray(features){return turf.union(turf.featureCollection(features))}function divideArea(bounds,numAreas,horizontal=true){let bbox=turf.bbox(bounds);let minX=bbox[0];let minY=bbox[1];let maxX=bbox[2];let maxY=bbox[3];let deltaX=(maxX-minX)/numAreas;let deltaY=(maxY-minY)/numAreas;let subAreas=[];for(let i=0;i<numAreas;i++){let points;if(horizontal){points=[[[minX+i*deltaX,maxY],[minX+(i+1)*deltaX,maxY],[minX+(i+1)*deltaX,minY],[minX+i*deltaX,minY],[minX+i*deltaX,maxY]]]}else{points=[[[minX,maxY-i*deltaY],[maxX,maxY-i*deltaY],[maxX,maxY-(i+1)*deltaY],[minX,maxY-(i+1)*deltaY],[minX,maxY-i*deltaY]]]}let subArea=addBuffer(turf.polygon(points),.01);subAreas.push(turf.intersect(turf.featureCollection([subArea,bounds])))}return subAreas}function walkableArea(features,bounds,options={},workerId,progressCallback,progress={processedPolygons:0,totalPolygons:0}){let LANE_WIDTH=3;let RAIL_WIDTH=3;let PARALLEL_PARKING_WIDTH=2;let DIAGONAL_PARKING_WIDTH=5;let REMOVE_BUILDING_INNER_RINGS=true;let WALKABLE_ROADS=false;let UNWALKABLE_GRASS=false;if(options.laneWidth)LANE_WIDTH=options.laneWidth;if(options.railWidth)RAIL_WIDTH=options.railWidth;if(options.parallelWidth)PARALLEL_PARKING_WIDTH=options.parallelWidth;if(options.diagonalWidth)DIAGONAL_PARKING_WIDTH=options.diagonalWidth;if(options.flattenBuildings)REMOVE_BUILDING_INNER_RINGS=options.flattenBuildings;if(options.walkableRoads)WALKABLE_ROADS=options.walkableRoads;if(options.unwalkableGrass)UNWALKABLE_GRASS=options.unwalkableGrass;let filteredFeatures=filterFeatures(features,bounds);let roads=filteredFeatures.roads;let railways=filteredFeatures.railways;let buildings=filteredFeatures.buildings;let waterBodies=filteredFeatures.waterBodies;let restrictedAreas=filteredFeatures.restrictedAreas;let grass=filteredFeatures.grass;let benches=filteredFeatures.benches;let trees=filteredFeatures.trees;let smallMonuments=filteredFeatures.smallMonuments;let barriers=filteredFeatures.barriers;let land=filteredFeatures.land;let coastlines=filteredFeatures.coastlines;let bridges=filteredFeatures.bridges;let boundaries=filteredFeatures.boundaries;if(WALKABLE_ROADS){roads=[]}else{roads=processRoads(roads,LANE_WIDTH,DIAGONAL_PARKING_WIDTH,PARALLEL_PARKING_WIDTH)}buildings=processBuildings(buildings,REMOVE_BUILDING_INNER_RINGS);railways=addBufferMany(railways,RAIL_WIDTH/2);waterBodies=processWater(filteredFeatures,bounds);benches=processBenches(benches);trees=processTrees(trees);smallMonuments=processSmallMonuments(smallMonuments);barriers=processBarriers(barriers);const isNotLand=land.length==0&&buildings.length==0&&roads.length==0;if(boundaries.length==0){if(isNotLand){return addBuffer(turf.centroid(bounds),.01)}}else if(coastlines.length>0){if(!turf.booleanWithin(bounds,boundaries[boundaries.length-1])){let unmappedWater=difference(bounds,boundaries[boundaries.length-1]);waterBodies.push(unmappedWater)}}let unwalkablePolygons=buildings.concat(waterBodies,roads,railways,restrictedAreas,benches,trees,smallMonuments,barriers);if(UNWALKABLE_GRASS){unwalkablePolygons=unwalkablePolygons.concat(grass)}if(options.customFeatures){console.log("Custom geometries:");console.log(options.customFeatures.features);unwalkablePolygons=unwalkablePolygons.concat(options.customFeatures.features)}let walkableAreaPolygon=bounds;for(let f of unwalkablePolygons){try{let diff=difference(walkableAreaPolygon,f);if(diff===null)diff=addBuffer(turf.centroid(bounds),.01);walkableAreaPolygon=diff}catch(error){console.log("Error with feature:");console.log(f);console.log(error)}}return walkableAreaPolygon}function walkableAreaWithSubAreas(features,bounds,options,workerId){bounds_area=turf.area(bounds);numDivisions=Math.ceil(bounds_area/1e5);numDivisions=numDivisions>=1?numDivisions:1;console.log("Number of area divisions: "+numDivisions);let subAreas=divideArea(bounds,numDivisions,horizontal=false);let subAreaFeatures=[];let totalPolygons=0;let unwalkablePolygons=[];for(let subArea of subAreas){let subFeatures=[];for(let feature of features){if(turf.booleanIntersects(feature,subArea)){subFeatures.push(feature)}}subAreaFeatures.push(subFeatures)}progress={totalPolygons:totalPolygons,processedPolygons:0};for(let i=0;i<subAreas.length;i++){unwalkablePolygons.push(walkableArea(subAreaFeatures[i],subAreas[i],options,workerId,null,progress));if(workerId!==undefined&&workerId!==null){postMessage({progress:true,processedPolygons:i+1,totalPolygons:subAreas.length,workerId:workerId})}}results=[];try{results=unionArray(unwalkablePolygons)}catch(e){console.log("Error on union... trying again");console.log(e);unwalkablePolygons=addBufferMany(unwalkablePolygons,.1);try{results=unionArray(unwalkablePolygons)}catch(e1){console.log(e1)}}return results}